⁸JAVA
D:\java_initials\java_essentials  (all files of learning is saved here] 
JDK is primarily used for code execution and has prime functionality of development.	
On other hand JRE is majorly responsible for creating environment for code execution.	
JVM on other hand specifies all the implementations and responsible to provide these implementations to JRE.

 
1. JAVA BASICS--------------------------------------------------------------------
 
This is very basic code in java to print hello world.
Psvm is a short cut to write the public static void main
(String[] args).
Java is a case sensitive language .
Everything in java is written in classes.
A class is a user defined blueprint consisting of attributes and methods.
------------------>public class Basic {
Public means this class basic is accessible from anywhere in the entire code.
Class word is here used for to create a class with name and always is used, java is always written in class.
Basic is the name of class and it can be any name with properly followed rules.
{} this curly braces after the word class contains all the methods, function and code.
------------------>public static void main(String[] args) {
Public is a access modifier which means that it the main method is access from anywhere.
Static allow to call the class without creating the object for that class.
Void means that main method doesn’t return any value.
Main is the name of method, this is the entry point of java program from here jvm starts executing code.
------------------>String[] args
String[] signifies the array of list.
Args is the name array parameters.
------------------>System.out.println
System is predefined class in java library that provides access to the system related resources.

Out is the static field which connected to the output stream which is responsible to show output in console.
Print and println is used to print what is inside of braces the difference between both is that when we use println the cursor moved to the next line which means after the printing one statement every other will be print after that line but in print cursor do not move to the next line.
> // is used to write comment in java i.e. ctrl+/









	
2. JAVA VARIABLES & DATA TYPES-----------------------------------------------------------------
In java variables are called to store data inside it, A name for a  memory location that stores a value  .Whereas Data type tells what type of data is stored inside of variable.
There are mainly two type of data types in java:
1.	primitive data type is that which is predefined 
2.	non primitive data type is generated by programmer and it has dynamic storage for instance array, object, string
Primitive data types are:
byte	Stores whole numbers from -128 to 127
short	Stores whole numbers from -32,768 to 32,767
int	Stores whole numbers from -2,147,483,648 to 2,147,483,647
long	Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
float	Stores fractional numbers. Sufficient for storing 6 to 7 decimal digits
double	Stores fractional numbers. Sufficient for storing 15 to 16 decimal digits
boolean	Stores true or false values
char	Stores a single character/letter or ASCII values
In java there are different type of variables such as 
string =stores text which is surrounded by double quotes for example “hello world”
int =stores integer 
float =stores floating numbers such as 65.36 
char =stores single characters which is surrounded by single quotes for example ‘j’
Boolean =stores only two values true/false
SYNTAX::
Type variablename = value;

String name = “karn”;
Int num = 108;
System.out.println(name+num);


Int numm;
Numm =108;
System.out.println(numm);

If you change the value of numm from 108 to anyother than new value will be consider
Int numm=108;
Numm = 103;

If somehow you don’t want anyone to change the value of any variable than you have to use the final keyword 
For example
Final string name =”karn”;
Name =”arjun” //this will throw error 

You can print many variables in one print statement than it can be done by + sign for example
String name = “karn”;
Int num= 108;
System.out.println(“here is” + name+num);


Also you can declare many variable in one statement if they have the same data type for example
Int a=1, b=0, c=8;
System.out.println(name+num);
Int a,b,c;
a=b=c=108;
System.out.println(name+num);


In java data type is used to define the type of value numbers can be typed with many but in java mainly all use int and float when we use float we put f after the value and d in double

There are some rules for naming of variable in java:
1. Name of variable cant start with number.
2. Name of variable cant be from reserved words like int, static, void etc.
3. Name of variable cant include whitespace.
4. Name of variable can contain letters,digits,underscore and dollarsign.
5. Name of variable can use camelCase.
6. Name of constant variable should be in uppercase.
7. They are case sensitive 
Well this rules are belongs to identifiers. A identifier is used to uniquely identify the entities within the program. Identifier provide a way to refer to them and distinguish them from others while variable is a specific type of identifier, it’s a name given to a memory location that can store a value.



3. INPUTS IN JAVA----------------------------------------------------------------------------------------
import java.util.Scanner;

public class MyProgram {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in); // Created once

        System.out.print("Enter your name: ");
        String name = input.nextLine();

This is the basic and general code which is used to take input in java rather than only this there are also other ways to take input like bufferedreader but we will use this scanner method to take input in our programs as this is widely used.
Lets break down the flow of taking input in java
---------> import java.util.Scanner;
Import keyword in java is used to bring classes or interface from other package to yours.
Java.util.scanner  specifies the full path to the scanner class and java.util is the package where the scanner class is located and scanner is the name of the class itself .
This is important to import the scanner class because scanner class in java is a tool that used to take input from various sources like keyboard, files etc.
------->Scanner input = new Scanner(System.in);
Scanner is the data type of the variable input .
Input is the name that we can choose whatever we want.
New keyword is used to create a new instance of a class (object) .
Scanner(System.in) is the constructor call for the scanner class. It initializes the new Scanner object.
System.in represents the input stream which take input from the keyboard .
-------->System.out.print("Enter your name: ");
System.out refers to the standard output stream which means it will print text to the console of your window.
Print is used to print text
-------->String name = input.nextLine();
String is the data type of the variable indicates which data type of input can be taken.
Name is the name of variable can be anything.
Input is the scanner object created earlier.
Nextline() is a method of the scanner class.

System.out.printf("enter the rate:");
int ac = input.nextInt();
System.out.println("enter the string:");
String aa=input.nextLine();
While there is a common problem faced by programmers and that is when we use nextInt() or nextFloat() or nextDouble() and use nextLine() just after it then when we run the program we won’t be able to give input for nextLine().
WHY= this happen because nextInt() reads the input but leaves a new line /n behind in the input buffer and after it when nextLine() call immediately then it takes that empty new line as a input and proceed further.
SOLUTION= to eliminate this there are mainly two ways 
First is consume the extra line by using
Input.nextLine(); for example:

Scanner input = new Scanner(System.in);

        System.out.println("enter the principle:");
        int ab = input.nextInt();

        input.nextLine(); // Consume the leftover newline

        System.out.println("enter the string:");
        String aa = input.nextLine();


Second is to read all input as inputLine() and then convert them as per the requirement.
For example:

Scanner input = new Scanner(System.in);

        System.out.println("Enter a double value:");
        double doubleValue = Double.parseDouble(input.nextLine()); 

        System.out.println("Enter a float value:");
        float floatValue = Float.parseFloat(input.nextLine()); 

        System.out.println("enter the rate:");
        int ac = Integer.parseInt(input.nextLine()); 

        System.out.println("enter the string:");
        String aa = input.nextLine();

        System.out.println(aa + ab);
        input.close(); // Close the Scanner


use input.close(); in last in code to ensure there is no more using of scanner class to take input and also it is a best practice to use it.
Scanner classes which is used to take inputs commonly:
•  nextInt(): Reads an integer. 
•  nextFloat(): Reads a float. 
•  nextDouble(): Reads a double. 
•  nextBoolean(): Reads a boolean value (true or false). 
•  nextLine(): Reads the entire line of input, including spaces. 
•  next(): Reads the next token (a word separated by whitespace). 
•  nextByte(): Reads a byte. 
•  nextShort(): Reads a short. 
•  nextLong(): Reads a long.
Some of uncommonly used scanner classes are to take inputs:
Radix(), reset(), hasNext() and more.





Program to read character from the input
Scanner yo = new Scanner(System.in);
        System.out.println("Enter the text ");
        char an = yo.next().charAt(2);
        System.out.println(String.valueOf(an));
























4.  TYPE CASTING----------------------------------------------------------------------------------------------
Type casting in Java is the process of converting a value from one data type to another.
This can be done in two ways:
One is implicit conversion which is done automatically also known as implicit/widening casting=converting a smaller type to larger type.
byte -> short -> char -> int -> long -> float -> double
int x = 10;
long y = x; 
float a = 5.5f;
double b = a;

Second is explicit conversion which is done manually by the programmer also known as explicit/narrowing casting=converting a larger type into a smaller type.
double -> float -> long -> int -> char -> short -> byte

double price = 9.99;
int roundedPrice = (int) price; 
// Explicit casting: double to int (narrowing) - truncates decimal



6. OPERATORS

7. STRING METHODS

8. BOOLEANS

9. CONDITIONAL STATEMENT00

9. Math in java








 

Wfesgh
Aweg
STRING IN CW PLAYLIST






 
10. CONDITIONAL STATEMENT--------------------------------------------------------------------------------------------
Conditional statement are the basic control flow mechanism in java which execute when it satisfy the condition.
If statement
Syntax:
if (condition) {
    // Code to be executed if the condition is true
}
If statement simply execute a set of code when a specific condition satisfied.

If else statement
Syntax:
if (condition) {
    // Code to be executed if the condition is true
} else {
    // Code to be executed if the condition is false
}
This is used when you want something to print a condition satisfied but if not then execute a another code. “if” will execute when condition is true otherwise “else” will run.
Else if statement
Syntax:

if (condition1) {
    // Code to be executed if condition1 is true
} else if (condition2) {
    // Code to be executed if condition1 is false and condition2 is true
} else if (condition3) {
    // Code to be executed if condition1 and condition2 are false and condition3 is true
} else {
    // Code to be executed if all conditions are false
}

This is used when there are more than two conditions and in each condition matched user want to execute different code. And if any of the particular condition satisfied then 
All the other condition code will not execute.




Nested if statement
Syntax:
if (condition1) {
    if (condition2) {
        // Code to be executed if both condition1 and condition2 are true
    } else {
        // Code to be executed if condition1 is true but condition2 is false
    }
} else {
    // Code to be executed if condition1 is false
}

This is used when user have conditions inside of a condition. If condition 1 is satisfied then it goes inside another if block and then again search for a matching condition and execute after it matched. Also here else if statement can be written in case of requirement.



Ternary operator
Syntax:
variable = (condition) ? expressionTrue :  expressionFalse;
condition specify the constraint and on basis of it the ternary operator will print the either expression first or second. If the condition satisfied then expression first will be print otherwise expression second.
Switch statement
Syntax:

switch (expression) {
    case value1:
        // Code to be executed if expression == value1
        break; // Important: Prevents fallthrough
    case value2:
        // Code to be executed if expression == value2
        break;
    case value3:
        // Code to be executed if expression == value3
        break;
    default: // Optional: Code to be executed if no case matches
}





11. BREAK AND CONTINUE-----------------------------------------------
The break and continue statement in java is used to alter the normal execution of conditional statement. It help to gain control in execution of conditional statement like early termination and skipping iterations.
Break;
Break sparingly to exit a loop when a specific condition is met, especially when continuing the loop would be inefficient or incorrect.
Continue;
The continue statement is used within loops to skip the current iteration and proceed to the next iteration of the loop.  It does not terminate the loop entirely like break.









12. CONDITIONAL STATEMENT CONTINUE-------------------------------------
Loop statements are fundamental control flow mechanisms in Java that enable the repeated execution of a block of code. They are essential for automating repetitive tasks and processing collections of data

FOR LOOP
Syntax:
for (initialization; condition; update) {
    // Code to be executed repeatedly
}

The for loop is typically used when the number of iterations is known in advance or can be easily calculated. It consists of three parts within the parentheses: initialization, condition, and update.
FOR EACH LOOP
for-each loop (also known as the enhanced for loop) is used to iterate over elements in an array or a collection (like List, Set, etc.) without needing to use an index. It simplifies the process of iterating through elements.
Syntax:
for (DataType variable : collection_or_array) {
    // Code to execute for each element
}
DataType: The type of the elements in the array or collection (e.g., int, String, etc.).
variable: A variable that represents the current element in the iteration.
collection_or_array: The array or collection you want to iterate over.
NESTED LOOP
General syntax:
for (initialization1; condition1; update1) {  // Outer loop
    for (initialization2; condition2; update2) {  // Inner loop
        // Code to execute in the inner loop
    }
    // Code to execute in the outer loop (after the inner loop finishes)
}

nested loop is a loop inside another loop. This is useful when you need to perform repetitive tasks that require multiple levels of iteration, such as working with 2D arrays, matrices, or generating patterns.

WHILE LOOP
Syntax:
while (condition) {
    // Code to be executed repeatedly
}
The while loop is used when the number of iterations is not known in advance and depends on a condition that may change during the loop's execution.

DO WHILE LOOP
Syntax:
do {
    // Code to be executed repeatedly
} while (condition);

do-while loop is similar to the while loop, but the code block is executed at least once before the condition is 1  checked. This guarantees that the loop body runs at least one time












13. OOPS----------------------------------------------------
Oops is a programming paradigm that organizes code into object data structure that contain both data(arrtibute) and behavior(methods).
Reasons to use oops:
1.	Organized
2.	Reusable
3.	Maintainable
4.	Scalable
5.	Understandable
There are four pillars of oops in java:
A] ENCAPSULATION -> hide data and only allow access through public methods.
B] ABSTRACTION -> focus on what on object does, not how it does.
C] INHERITANCE -> extend functionality from another class and modify or add specific behavior.
D] POLYMORPHISM -> the same method can perform different action depending on the object.

So you must wonder why is these and why only these are considered the pillar or java?
=> It's because they provide the fundamental structure and principles that make object-oriented programming so effective.
Abstraction: The Foundation of Simplicity
Encapsulation: Protecting and Organizing
Inheritance: Building on Existing Foundations
Polymorphism: Flexibility and Adaptability
Further more are coming of oops.. .. .
14. CLASS AND OBJECT 
Definition-
Class  (blueprint/template for creating object.)
It actually defines the properties and behavior of object of that class. It does not hold any specific data but define what kind of data its object will store and that is why it is not a real world entity.
Class just defined the nature and behavior of object. Further object take those methods and actually implement them.
Object  
(an instance of the class)= instance means a realization or actual occurrence of a class, when you create an object you are creating an instance of that class.
(an object is a variable of the type class)= this means that the object is a variable that stores information and behavior(methods) defined by the class.
(a class can be considered a data type for its object)= a class is a custom data type for its object as it defines the structure and behavior for objects.
An object behave according to the blueprint defined by the class just like int, float or str pre-built data types.
An object is a specific value or instance of that data type. Just like 5 is an instance of the int type or “hello world” is an instance of the str type.


SYNTAX:















 
Here are so many keywords and new names which seems to be very unknown so further it all will be unlocked one by one.
Decoding the syntax to declare class in java:
1. Class Declaration

Syntax:  [accessModifier] class ClassName { ... }
Necessary:  Yes, every class must have a declaration.
Why:  It defines the class and its accessibility.
Example:

public class Car { ... }

public:  Access modifier (optional, but commonly used for main classes).
class:  Keyword to define a class.
Car:  Name of the class (follows camelCase convention).


2. Fields (Variables)

Syntax:  [accessModifier] [static] [final] dataType fieldName [= initialValue];
Necessary:  No, but most classes have fields to store data.
Why:  Fields represent the state (attributes) of an object.


Example:

private String brand;
private int year = 2020;

private:  Access modifier (restricts access to the class itself).
static: Makes the field belong to the class, not individual objects.
final:  Makes the field constant (cannot be changed after initialization).
String brand:  Declares a field of type String.

3. Constructor

Syntax:  [accessModifier] ClassName([parameterList]) { ... }
Necessary:  No, but recommended if you need to initialize fields.
Why:  Constructors are used to set initial values for fields when an object is created.

Example:

public Car(String brand, int year) {
    this.brand = brand;
    this.year = year;
}
this.brand:  Refers to the class field (to distinguish it from the parameter).

4. Methods

Syntax:  [accessModifier] [static] [final] returnType methodName([parameterList]) { ... }
Necessary:  No, but most classes have methods to define behavior.
Why:  Methods define what an object can do.

Example:

public void displayDetails() {
    System.out.println("Brand: " + brand);
    System.out.println("Year: " + year);
}

void:  Indicates the method does not return a value.
displayDetails:  Name of the method (follows camelCase convention).

5. Main Method

Syntax:  public static void main(String[] args) { ... }
Necessary:  Yes, if you want to run the class as a program.
Why:  The main method is the entry point for Java applications.

Example:

public static void main(String[] args) {
    Car myCar = new Car("Toyota", 2015);
    myCar.displayDetails();
}

So why is class defined before the main method and what if it defined after the class method?
as we know that main method is the entry point in any java program so when the compiler starts compiling the code through entering the main method it will encounter defined objects of any class so it will need the biodata of that object that what is this object behavior, properties. So to know this the class must be declared before the main method so that that blueprint can be used by object to define its behaviors but what if I defined the class after the main method so then main method will try to use that class which is defined later in the code and while compiling the code it will throw “cannot find symbol” error. Java reads the code sequentially so when you compile your code the compiler reads the class definition first and during execution the JVM loads the necessary class in the memory and enter from the main methods to start the program. So all over defining the class before the main method is best practice.

Some Rules:
There can be only one public class per source file.

A source file can have multiple non-public classes.

The public class name should be the name of the source file as well which should be appended by .java at the end. For example − the class name is public class Employee{} then the source file should be as Employee.java.

If the class is defined inside a package, then the package statement should be the first statement in the source file.

If import statements are present, then they must be written between the package statement and the class declaration. If there are no package statements, then the import statement should be the first line in the source file.

Import and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.
15. CLASS ATTRIBUTES
Java class attributes are the variables that are bound in a class i.e., the variables which are used to define a class are class attributes.

Class Attribute= Refers to any variable declared in a class, including both instance and static variables.	Scope =Broader term.
Class Variable= Specifically refers to static variables that belong to the class, not instances.  Scope=Narrower term (subset).

SYNTAX:
[access modifier] [static] [final] dataType attributeName [= initialValue];
Access Modifier: Controls the visibility of the attribute.

public: Accessible from any class.

private: Accessible only within the same class.

protected: Accessible within the same package and subclasses.

Default (no modifier): Accessible within the same package.

static: Indicates that the attribute belongs to the class rather than an instance of the class. Static attributes are shared across all objects of the class.

final: Makes the attribute immutable (constant). Its value cannot be changed after initialization.

dataType: The type of data the attribute can hold (e.g., int, String, double, etc.).

attributeName: The name of the attribute (follows camelCase naming convention).

initialValue: Optional. The initial value assigned to the attribute.

Eg.
public class MathConstants {
    public static final double PI = 3.14159; // Final attribute
}
https://github.com/nikesh-repositry/java_initial/blob/main/oops_1.java
https://github.com/nikesh-repositry/java_initial/blob/main/oops_2.java
https://github.com/nikesh-repositry/java_initial/blob/main/oops_3.java
 
types: STATIC AND INSTANCE VARIABLE
The 2 types one is instance variable and then static variable, both have there own uniqueness and used based on the problem. instance variable is shared among instance and all of them have copy of the variable whereas the static variable is common among all the class.

 

Instance Variables---
Changes: When you modify an instance variable through an object, only that object’s value changes.
No Changes: Other objects’ instance variables remain unaffected.
•	Unique to each object.
•	Changes are localized to the object.
•	Accessed and modified through object references

Static Variables---
Changes: When you modify a static variable through an object or the class name, the change is reflected across all objects.
No Changes: Static variables cannot have different values for different objects. They are shared.
•	Shared across all objects of the class.
•	Changes are global and affect all objects.
•	Accessed and modified using the class name (preferred) or object references.
 

One more type of attribute is final attribute which simply can be formed using final keyword and it means value of that variable can’t be changed.

Accessing the class attributes(objects)
Class attributes are accessed by object or class instances.

Instance Attributes: Accessed using an object of the class.

Car myCar = new Car();
myCar.model = "Tesla Model S";

Static Attributes: Accessed using the class name.

Car.numberOfCars = 10;

Final Attributes: Accessed similarly to static attributes if they are static, or through an object if they are instance-specific. 
so we can access the class attributes and method by class object and to understand it well there are some coding terms need to be clarified.

DECLARATION= defines a variable or object by specifying its types and name.
Eg. Int age;

INSTANTIATION= creates an instance of a class(allocated memory for the object)
Eg. Car myCar = new Car();

INITIALIZATION= assigns initial values to the object properties.
Eg. car mycar = new car(“tata”);

ASSIGNMENT= sets or updates the value of a variable or object property.
Eg. age = 18;
     Mycar.setModel(“bmw”);
 
#Creation of an object= 
         ClassName objectName = new ClassName(); 

#“new” keyword =
•	The new keyword is used to create objects and allocate memory for them.
•	It calls the class constructor to initialize the object.
•	It returns a reference to the newly created object, which is stored in a variable.
•	Objects created with new are stored in the heap memory and remain there until garbage collected.

#Accessing of an object=
         objectName.attributeName; // Accessing an attribute
         objectName.methodName();  // Accessing a method

#Modifying of an object=
         objectName.setAttributeName(newValue); 
         // Using a setter method


 
Object Properties:
Object properties represent the state of an object. They are defined using instance variables (unique for each object) or static variables (shared across all objects). These properties store the data related to the object, such as name or age for a Person object. To access and modify these properties safely, getters (to retrieve values) and setters (to set values) are used, ensuring controlled access.

Object Class Methods:
Object class methods define the behavior of an object. They are written as instance methods (that operate on individual object data) or static methods (that operate at the class level). These methods perform actions using the object's properties. For example, a displayInfo() method in a Person class can print the name and age, demonstrating how methods use properties to define behavior. 








16. METHODS-----------------------------------------------------------------
Methods are the block of code which perform certain task
And defined in a class. Values are passed into methods and method is only invoked when it called. Methods are used where a certain task need to be performed many times and it promotes reusability, clarity etc.

Declaration of methods
Syntax:
accessModifier returnType methodName(parameterList) {
    // method body
}
Access Modifier: Defines the visibility of the method (e.g., public, private, protected, or default).
If we don’t specify any modifier then default is assigned.

Return Type: Specifies the data type of the value returned by the method. Use void if the method does not return any value.

Method Name: The name of the method, following Java naming conventions (camelCase).
Parameter List: A comma-separated list of input parameters, each with a data type and name.

Method Body: The block of code that defines the method's functionality.

Method signature:
The method signature consists of the method name and the parameter list. It does not include the return type or access modifiers.
Example: int add(int a, int b) has the signature add(int, int)

public class Main {
  static void myMethod() {
    // code to be executed
  }
}
If you want that method don’t return anything then use void keyword in declaration.

Return statement:
The return statement is used to exit a method and optionally return a value to the caller.




Types of methods
1. based on definition (built in and user defined methods)
a) Built-in methods 
Built-in methods, also known as library functions or predefined methods, are part of the Java Standard Library. They are provided by Java to perform common operations without requiring users to implement them from scratch. These methods are available in various classes within the java.lang, java.util, and other packages.

Examples of Built-in Methods:
String Class: length(), toUpperCase(), toLowerCase()

Math Class: sin(), cos(), sqrt()

Arrays Class: sort() for sorting arrays

Collections Framework: Various operations like sorting (Collections.sort()), searching (Collections.binarySearch())

b) user defined methods
User-defined methods, on the other hand, are created by developers themselves to encapsulate specific logic or functionality that is not already available in the standard library. These custom functions can be tailored to meet specific requirements of an application.

Characteristics:
Custom Logic: They contain code written by developers.

Reusability: Promote code reusability across different parts of a program.

Modularity: Enhance modularity by breaking down complex tasks into simpler ones.








c) instance method
Belong to an instance of a class (object)
Can access instance variables and other instance methods.
d) static method
Belong to the class itself, not to any specific object.
Cannot access instance variables or instance methods directly.
e) constructor method
Special methods used to initialize objects.
Have the same name as the class and no return type.
f) getter and setter methods
Used to access (get) and modify (set) private instance variables.
g) overloaded method
Methods with the same name but different parameter lists.
h) Recursive Methods
Methods that call themselves to solve a problem.
i) finalize method
called by the garbage collector before object reclamation, intended for cleanup.
It all types will be covered step by step.
Method Parameters and Arguments
parameters=Variables defined in the method signature.
Arguments=Actual values passed to the method when it is called.
Parameters are the spaces for which any value will assign it can be places by programmer or user input as arguments

 method overloading(discuss later)
Method overloading allows you to define multiple methods with the same name but different parameter lists.
 method overriding(discuss later)
Method overriding occurs when a subclass provides a specific implementation for a method already defined in its superclass.
Access modifiers
accessModifier returnType methodName(parameterList) {
    // method body
}
Here in syntax of method access modifier plays a vital role which Control the visibility of methods.
public:
The method is accessible from any other class.
private:
The method is accessible only within the same class.
protected:
The method is accessible within the same package and subclasses.
Default (no modifier):
The method is accessible only within the same package.

----till now we see what is method and what is syntax also its glimpse of method types
Now once again with a serial manner
What is method
Then
Method Syntax for creation 
Then 
Method Types
Then 
How to access or call method
Then
Method with parameters and various return values
Then 
Method overloading
Then
Method scope
Then
Method arguments and this keyword
Then
Constructors 
So, method is a block of code that performs a specific task.

Syntax:
[access modifier] [static] [return type] methodName([parameter list]) {
    // Method body (code to execute)
    [return statement;]
}

Method types discussed earlier but now again 
BUILT-IN METHODS:
It just a simple methods which is already present in java libraries which helps us to perform common tasks without rewriting code.
Like  length() property and math library 
USER DEFINED METHODS:
As the name said it is defined by programmer like simple method to add two integers or anything like that.



INSTANCE METHOD:
Now this type of method belong to the object of a class and it operate on instance variables but it can also access the static variables. Unlike instance variable where all instance has its own copy of instance variable , instance of class do not have its own copy of instance methods. It is access by using an object.
STATIC METHOD:
This method belong to the class, not to any object. And perform tasks that do not depend on instance variable as static method can not access instance variable directly unless an object is explicitly passed and static method can be access using the class name or direct if they are in the same class.
CONSTRUCTOR METHOD:
This is a special method to initialize objects, which purpose it to set initial values for object properties. Will discuss later more
GETTER AND SETTER METHOD:
Method to access use get and for accessing use set for private instance variables which goal is to encapsulate data and control access. Will discuss more later

OVERLOADED METHOD:
Consider if you want to take input from the object or input but it can be either two or three input so you have a choice to make two different method for both cases or you can use two method with the same name let the compiler decide which method is suitable to perform further action.
Method with the same name but different parameter lists. It also called compile time polymorphism as in this type the compiler determines which method to call based on the number, type, and order of the argument passed. This allow to not to create the same method with different types or number of arguments.

The method must differ in:
1. the number of parameters
2. the type of parameters
3. the order of parameters

>>Rules for method overloading:
Method Name Must Be the Same
All overloaded methods must have the same name.
Parameter List Must Be Different:
The methods must differ in the number, type, or order of parameters.
Return Type Does Not Matter:
Method overloading is not affected by the return type. Two methods cannot have the same name and parameter list but different return types.

Access Modifiers Can Vary:
Overloaded methods can have different access modifiers (e.g., public, private).

Static and Non-Static Methods:
A static method can be overloaded by a non-static method and vice versa.
QUESTION] if all the parameters of method is same then which one is sufficient to satisfy to form overloaded method a]static and non static method b]return type c]access modifier d]non of these
answer is non of these because all these three are not consider as method signature
working of method overloading 
The Java compiler determines which method to call based on the number, type, and order of the arguments passed. This decision is made at compile time, which is why method overloading is an example of compile-time polymorphism.
Step-by-Step Working
1.	When a method is called, the compiler checks the method name and the arguments passed.
2.	It matches the arguments with the parameter lists of all overloaded methods.
3.	If a match is found, that method is called.
4.	If no match is found, a compilation error occurs.
Common error:
A] Same Parameter List, Different Return Type:
This is not allowed and will result in a compilation error.
B] Ambiguous Method Call:
If the compiler cannot determine which method to call due to ambiguous arguments, it will throw an error.
>Java supports automatic type promotion when calling overloaded methods.
RECURSIVE METHOD:
A recursive method in Java is a method that calls itself, either directly or indirectly. It's a technique where a problem is solved by breaking it down into smaller, self-similar subproblems.
FINALIZE METHOD:
The Java finalize() method of Object class is a method that the Garbage Collector always calls just before the deletion/destroying the object which is eligible for Garbage Collection to perform clean-up activity. Clean-up activity means closing the resources associated with that object like Database Connection, Network Connection, or we can say resource de-allocation. We will more about it later.







Calling of methods/how to access methods
Syntax of Accessing any method depend on method type, access modifiers. 
A] accessing instance methods:-----
1) using an object reference(most common way)
create an object of the class and then the object reference to call the method.
Syntax: 
MyClass obj = new MyClass();
obj.instanceMethod();

2)accessing within the same class(implicitly)
Think there are instance methods of any class then you can call another instance method directly without using this keyword. Well this call would be consider as explicit call because method x accessing method y with in the same class
Syntax
instanceMethodName(arguments); or this.instanceMethodName(arguments);

3)accessing from a subclass(inheritance)
Consider it there is a parent class having instance method which can be public or protected then it can be access by its subclass or child class 
Syntax:
methodName();

B] accessing static method:-------
1) using the class name(best practice)
You can use the class name directly without creating object to call the static method.
Syntax:
ClassName.staticMethodName(arguments);

2) using object reference(not recommended)
We can call the static method using object reference just like instance method and it will work as well but it is not consider to use as this creates confusion and less readable code.

3)accessing within the same class
Calling other static method with in a same class
Syntax: staticMethodName(arguments);
Parameters and arguments and return types
                          --------PARAMETERS-------
Parameter are variable defines in the method signature, basically it acts like a variables inside the method as information can be passed to method as parameters.
Whenever you want to pass some values to any method to proceed with the desire data , that passed values goes to parameters of method.
You can add as many parameters as you want separating them with comma.
Syntax: 
public void methodName(DataType parameter1, DataType parameter2) {
    // Method body
}
Points to remember-
-parameters are local variable to the method.
-parameters can have a custom object type
-the order in which parameters are declared is crucial.
-method overloading relies on having different parameters lists
>>VARIABLE ARGUMENTS(varargs)<<
Consider if want to add number given from the input but it is impossible to know how many numbers will be provided by the user even if you create overloaded method to tackle this problem even then it would be worse so to eliminate this type of problem varargs comes in the picture where user is allowed to pass zero or more arguments of the same type to a method. This feature simplifies method declarations when the number of arguments is uncertain or variable (not fixed).
Syntax:
returnType methodName(dataType... variableName) {
    // Method body
}
>... ellipsis indicates that the method accepts zero or more arguments of that data type.
>The name of the varargs parameters which behaves like an array inside the method.
>Only one varargs parameter is allowed in a method, and it must be the last parameter of the method.



RETURN TYPE
Specifies the type of value the method returns.
We often used the void return value which means the method do not returning any value. Otherwise return type could be int , string or other.

public ReturnType methodName(parameters) {
    // Method body
    return value; // 'value' must match the return type
}

                      ---------ARGUMENTS---------
Arguments are the actual value which are passed to a method. It corresponds to the parameters which are defined in the method. Arguments are the way to provide input to a method.
Syntax: eg:
For static method
MyClass.staticMethod("John", 30);

For instance method
MyClass obj = new MyClass();
obj.instanceMethod("Jane", 25);
*When you call a method, the values you pass are called arguments. The variables in the method definition that receive these values are called parameters.
Command-Line arguments
Command-line arguments are parameters passed to a Java program when it is executed from the terminal or command prompt. These arguments allow users to provide input to the program at runtime.
Commonly used for configuration, file paths, or other runtime parameters. Also for quick input without using scanner class or bufferedReader.
Working
public static void main(String[] args)
Command line arguments are passed to the main method of java program. args is array which holds the command line arguments passed during the program execution and the String stores the command line arguments. The first argument is arg[0] then arg[1] and so on and if no argument is passed the args array is empty and length is 0.
All arguments which are passed here have the data type of string and it can be converted explicitly using any method like Integer.parseInt(str).







17. SCOPE---------------------------------------------------------------------------------------
scope refers to the region of the program where a variable, method, or class is accessible.
Several types of scope
i.	Class Scope (Instance Variables)
Attributes and fields which are declared within a class but outside of any method, constructor and block. The lifetime of these attributes exists as long as the object they belong to exists. These can be access by any instance method within the class by using object reference or using this keyword.
ii.	Method Scope (Local Variables)
Local variables are declared within a method, they are used for temporary storage within the method. The lifetime of these local variable exists only during the execution of the method. Local variable are only visible within the method in which they are declared. They can be accesses directly by their name within the method.


iii.	Block Scope (Variables inside blocks like loops or conditionals)
Block variable are declared within a block of code like inside of any if statement, for or while loop. Block is a section of code enclosed in curly braces {}. The lifetime of these variables exists only during the execution of the block and they only visible within the block in which they are declared. These can be access directly by their name within the block.
iv.	Static Scope (Static Variables and Methods)
Static variables and methods belong to the class itself and not to any specific object, they are declared using static keyword. The lifetime of static method and variable exists throughout the entire duration of the program execution. Static members are accessible from anywhere within the class and also be accessed from outside of class using class name.



v.	Constructor Scope (Variables inside constructors)
Variables which are declared within a constructor are local to that constructor including constructor parameters. The lifetime of constructor variables is only sustain during the execution of the constructor. They are only visible within the constructor and can be access directly by their name within the constructor.
18. CONSTRUCTOR
A constructor is a special method to initialize newly created object. It sets initial values for object attributes. The  constructor is called when an object of a class is created. All classes have constructors, either you define or java will automatically provide a default constructor which will initializes all member variables to zero.
Syntax:
[access modifier] ClassName([parameter list]) {
    // Constructor body
}



Characteristics:
 	Constructor name must be same as the class name. 
 	It has no return type, not even void.
 	It is called automatically when an object is created.
Rules of java constructor
•	The name of the constructors must be the same as the class name.
•	Java constructors do not have a return type. Even do not use void as a return type.
•	There can be multiple constructors in the same class, this concept is known as constructor overloading.
•	The access modifiers can be used with the constructors, use if you want to change the visibility/accessibility of constructors.
•	Java provides a default constructor that is invoked during the time of object creation. 
•	If you create any type of constructor, the default constructor (provided by Java) is not invoked.

Types of constructors:
1. default constructor
It is a constructor with no parameters, invokes automatically by java to initialize the object in case no constructor is defined.
2. parameterized constructor 
A constructor which takes parameters to initialize the object attribute.
3. copy constructor
A constructor that creates an object by copying another object of the same class.
4. no-args constructor
The constructor which does not accept any argument.

You can not call the constructor explicitly like the regular methods.
Also while defining the constructor don not attach any return type.
Constructor overloading
When a class has multiple constructors with same name but different parameter lists known as constructor overloading.
This allow you to create objects with different initial states, depending on the available information.
Constructor can have different:
•	Number of parameters
•	Data types of parameters
•	Order of parameters
Constructor overloading is an example of compile time polymorphism ( static polymorphism ). The compiler determines which constructor to call at the compile time based on the arguments passed during object creation.




This keyword
This keyword used for
It refer to the object that is currently in action to execute a method of constructor.
It resolve ambiguities between instance and local variables and enable  constructor chaining.
>refer to the current object( it distinguish between instance variables and parameters or local variable with the same name, this is common in constructor or setter methods)
>invoking another constructor in the same class( constructor chaining)
>returning the current object( useful for method chaining)
>this refer to the inner class instance
<>this can not be used in static method or blocks, which belong to the class itself, not an instance.
<>this() must be the first statement in a constructor if there is a use of it.


 
Constructor chaining
It is a technique where one constructor calls another constructor within the same class or in its parent class ultimately helps to reduce code duplication and make program more readable and efficient.
So there are 2 types of constructor chaining
A) within-class constructor chaining(using this())
B) inheritance-based constructor chaining(using super())
Super() will be teach further in inheritance<><>
A))
SYNTAX:
this();        // Calls no-arg constructor
this(arg1);    // Calls constructor with 1 parameter
this(arg1, arg2); // Calls constructor with 2 parameters

RULES:
•	Must be the first statement in a constructor.
•	You cannot used this() twice in a constructor.
•	Cannot be used with super() because only one can be called first.
WORKING:
First you use this() followed by appropriate parameters to invoke another constructor i.e. just follow the syntax and type the argument then compiler automatically find out in which constructor you want to pass arguments. And then the called constructor executes first, then control returns to the calling constructor to finish its work.
19. ACCESS MODIFIERS
In java access modifiers controls the accessibility, visibility of variables, methods, constructors. It defines that who can use or see these members and provide encapsulation in the program.
There are 4 types of access modifiers:
Public, protected, default(no keyword required), private
PUBLIC=>use it when you want a member to be available to all classes and to all packages but you have import it in order to use in other packages. Commonly used for methods in APIs or classes meant to be widely used. Use public keyword to use this.
DEFAULT=>use it when you want to limit access to classes in the same package that means it will be only accessible only within the same package. No keyword is required to use it.
PROTECTED=>use it when you want the member to be access within the same package and subclasses of supeclass in other package via inheritance, protected access modifier can not be applied to class and interface and method & fields in a interface cannot be declared protected. Use protected keyword to use this.
PRIVATE=>use this for strict encapsulation, it provide accessible only within the same class and force access through setter/getter methods. Use private keyword to use it.
Comparison table:
 
public → Global access
protected → Package + Subclasses
default → Package only
private → Class only





20. WRAPPER CLASS----------------------------------------------------------------------------
Definition= A wrapper class is a class which wrap a primitive data type into an object.
So why is this concept in java why do we study this::
Well java is not consider as 100% object oriented language due to static method and variables and  primitive data type like int, char, Booleans etc but wrapper class encapsulates these primitive types (which are simple and raw values stored in memory for efficiency) into object because there are times when you need these primitives to behave like an object , these wrapper classes are used in arraylist, generics and collections etc these are designed to work with objects.
There are 8 primitive data types in java and for each data type java provides a corresponding wrapper class in java.lang pakage.
byte → Byte	                    char → Character	
short → Short	              boolean → Boolean
int → Integer	                    double → Double	
long → Long	                    float → Float

                       need of wrapper classes?
•	primitive types cannot be assigned the value null but the wrapper class objects can be null, this is useful in cases where you need to represent the absence of a value.
•	You cannot call methods on primitives or pass it to something but being object can.
•	Primitives are lightweight and fast but Java collection only work with objects not primitive.
•	Wrapper classes provide useful methods for conversions, parsing and manipulation.
Each wrapper class is essentially a container that holds a primitive value. Eg
An Integer object wraps an int.
A Double object wraps a double.
                        =Features of wrapper class=
1. immutability= wrapper classes are immutable i.e. once created then their values cannot be changed. Any operation that appears to modify the values  actually created a new object.
2. autoboxing and unboxing= introduced in java 5
Autoboxing: automatically converts a primitive to its wrapper class when an object is expected
Unboxing: automatically converts a wrapper object to its primitive type when a primitive type when a primitive is needed.
3. caching: a performance optimization technique where frequently used wrapper objects are stored and reused, rather than creating new objects each time.
=construction of wrapper object=
1. using constructors(older way, now less common)
Integer integerObj = new Integer(42);

2. using valueOf() method(preferred for efficiency)
Integer integerObj = Integer.valueOf(42);

3. autoboxing(automatic conversion)
Integer integerObj = 42; 

=Important methods in wrapper classes=
1. valueOf(): returns an instance of the wrapper class
Integer i = Integer.valueOf("100");

2. parseXxx(): converts string to primitive
int num = Integer.parseInt("123");

3. xxxValue(): converts wrapper to primitive
int num = i.intValue();

4. toString(): returns string representation
String s = i.toString();

5. compareTo(): compares two wrapper objects
Int result = i.compareTo(anotherInteger):

6. MAX_VALUE and MIN_VALUE:
System.out.println(Integer.MAX_VALUE); // 2147483647

=class specific methods=
Characters:
Character.isDigit('5'); // true
Character.isLetter('a'); // true
Character.toUpperCase('a'); // 'A'

Integer/long:
Integer.toBinaryString(10); // "1010"
Integer.toHexString(255); // "ff"

>wrapper class consume more memory than primitives









21. GARBAGE COLLECTION-----------------------------------------------------------------------------------------
Garbage collection in java is an automatic memory management process which is handled by the JVM, what it actually do is identifies object that are no longer in use by the program and reclaims that runtime unused memory then makes that memory available for new object allocations.
In short it cleans up the unused objects known as garbage. In java developers don’t have to manually allocate or deallocate memory like in c or c++ instead, JVM garbage collector takes care those unused memory.
Why do we need it
1. it saves program from memory leaks i.e. objects are retained in the memory even though when they are no longer needed by the application.
2. developer don’t need to manually free up spaces, which is time consuming and error prone.
3. code would become little bit messy with memory management logics, ultimately reducing readability and maintainability.
Working
Whenever you run any program in java the JVM divides that into three threads 1. Live/main thread 2. Thread scheduler 3. Garbage collector. Then when you create an object with new keyword then java allocates memory from the heap which means objects are stored in the heap, a region of memory managed by the JVM, garbage collection operated on the heap. After this JVM determines which objects are still in use and if objects not reachable from any live thread or static reference, if there is no way to access an object then that is eligible for GC.
Root reference are the starting points that the garbage collector used to determine which objects are still in use which is reachable and which objects are eligible for garbage collection (unreachable). starting point for determining reachability such as 
>local variable on the stack
>static variable in classes
>active threads

There are different algorithm are used to collect garbage:
1. mark and sweep= first in mark phase the garbage collector identifies all reachable objects by starting from the root reference and tracing through object graph and unreachable objects are marked as garbage then in sweep phase the collector reclaims memory from unreachable objects, making it available for new allocations.
2. generational garbage collection
3. mark compact and others
There are types of garbage collector some modern collectors
Serial GC, parallel gc, CMS, G1, ZGC
Q) when does garbage collection happen?=  GC is triggered automatically by the JVM when:
•	The heaps runs low on memory.
•	A specific generation fills up like Eden
•	The app explicitly calls System.gc() but this is just a suggestion not a guarantee for clean up that decide by JVM only.
22. Finalize() method
It is a special method defined in the object class (object class is the superclass of all classes in java) it is intended to be called by the garbage collector just before an object space is reclaimed. The idea was to give an object a chance to perform cleanup operation before its destroyed like releasing resources eg. closing files and network connections.
Syntax: (it is empty method)
protected void finalize() throws Throwable{
                  //empty in  object class
}
working
when gc finds that any object is no longer references to it from live threads or static variables then it marks the object as eligible for collection but before reclaiming the object memory if the object has overridden the finalize() method i.e. if the object has a finalize() method that has not already been called then the object is placed in special queue called the finalization queue (it belongs to the finalizer thread) then the finalize() method executes once per object and after completion the object is eligible for memory reclaimation In the next GC cycle. This whole process gives the object a last chance to clean up resources that the GC can not handle automatically such as non memory resources.
Characteristics
There is no guarantee when of if the finalize() will be called
The finalize() method is called at most once per object.
Finalize adds overhead to garbage collection and objects with finalize() persist longer in memory.
There are many more concepts in gc and finalize()…
Problems with finalize()
Unreliable execution=the jvm might exit without calling finalize()
Performance issues
Security risks
Exception handling










23. PACKAGES--------------------------------------------------------------------------------------------------
A package in java is a mechanism for organizing related classes, interfaces and other types into a namespace.
Need of packages
•	Namespace management
•	Organization
•	Access control
•	Reusability
•	Standardization
There are 2 types of packages:
a) built in packages(predefined)
provided by java (JDK)
•	java.lang = core classes(automatically imported)
•	java.util = utility classes(arraylist, hashmap, Scanner)
•	java.io = input/output operation(file, inputstream)
•	java.net = networking(url, socket)
•	java.sql = database access(connection, statement)
•	java.swing = advance GUI components
•	java.awt = GUI components (older)
b) user defined packages
created by developers to organize classes 
=creating a package=
To declare a package use the package keyword at the top of the java file 
Syntax: package com.mycompany.mypackage;
But it must be the first statement in the file and only one package can be declared per java file.

=>java enforce a mapping between package names and directory structure for eg.
Package: com.mycompany.mypackage
File location: ./com/mycompany/mypackage/MyClass.java









24. INNER CLASS------------------------------------------------------------------------------
The inner class is a class which is defined inside of any another class.
Why to use inner class?
>it’s a way to logically group classes that are closely related.
>inner class can access private members of the outer class, it enhance encapsulation.
>support callbacks and listeners common in GUI code.

=types of inner class=
1.non static inner class (regular) == defined inside another class without static
2.static nested class == defined with static modifier inside another class
3.method local inner class == defined inside a method of the outer class
4.anonymous inner class == a class without a name, instantiated in a single statement.
:::you can create more than one inner class:::
1. NON STATIC INNER CLASS
It is defined as a non static member of the outer class much like a method but it requires an instance of the outer class to exist because it is tied to that instance, an object of a non-static inner class holds an implicit reference to an instance of the outer class. It can access all members of the outer class including private members. To create an inner class object requires an outer class instance.
2. STATIC NESTED CLASS
A static nested class is a static member of the outer class. Unlike non static inner class it does not require an instance of the outer class to exist. It behaves like a top level class but scoped within the outer class. It can only access static members of the outer class directly and it instantiated without an outer class instance.
3. METHOD LOCAL INNER CLASS
A local inner class is defined inside a method, constructor or block. And it is only visible within that scope in which it is defined, like a local variable. It can only access final or effectively final variables of the method. It cannot be accessed outside the method. It must be instantiated within the same block.
4. ANONYMOUS INNER CLASS
An anonymous inner class is a local inner class without a name, declared and instantiated in a single statement. It is used for one time use cases like event listeners, threads. Like local inner classes, can access outer class members and final/effectively final variables. No explicit class declaration.
 
Non-static Inner Class	When inner class needs access to outer class instance variables.
Static Nested Class	When inner class doesn't need outer class instance (like a helper class).
Method Local Inner Class	When class is only needed inside a method.
Anonymous Inner Class	For one-time implementations (e.g., event listeners)


25. SINGLETON CLASS------------------------------------------------------------
A  singleton class is a design pattern that ensures only one instance of a class exists in the java virtual machine and provides a global point of access to it.
Used for logging, driver objects, caching, thread pools, database connections etc. 
Used when a single instance is needed to managed a shared resource like a database connection pool.
Used to coordinate actions across  the system like logging service.
Used to ensure consistent state across the application.
Characteristics 
•	Only one object of the class can exist.
•	A static method (typically getInstance()) provides access to the single instance.
•	The constructor is private to prevent external instantiaton.



There are ways to implement a singleton in java:
1) eager initialization(simplest approach)
The instance is created when the class is loaded, regardless of whether its needed.
Pros
Simple and thread-safe (class loading is handled by the JVM).
No synchronization overhead at runtime.
Eagerly available, so no delay on first access.
Cons
Instance is created even if unused, wasting resources if initialization is expensive.
No support for lazy loading.
When to Use
Small, lightweight objects.
When you’re sure the instance will always be needed.

2) lazy initialization
The instance is created only when first requested, supporting lazy loading.



Pros
Lazy loading—instance is created only when needed.
Simple to implement.
Cons
Not thread-safe: In a multi-threaded environment, multiple threads might create separate instances if they call getInstance() simultaneously.
Reflection can bypass the private constructor unless guarded.
When to Use
Single-threaded applications only.
Quick prototyping (but avoid in production).

3) thread safe lazy initialization(synchronized)
To make lazy initialization thread-safe, synchronize the getInstance() method.
Pros
Thread-safe—ensures only one instance in multi-threaded environments.
Lazy loading.
Cons
Performance overhead: Synchronizing every call to getInstance() is costly, especially after the instance is created.
Still vulnerable to reflection unless guarded.
When to Use
Multi-threaded apps with infrequent getInstance() calls.
When simplicity is preferred over performance.

4. Double-Checked Locking
This optimizes the synchronized approach by checking the instance twice—once without synchronization and once with—to reduce overhead.
Pros
Thread-safe and lazy-loaded.
Reduced synchronization overhead—lock is acquired only during initialization.
Efficient for frequent access.
Cons
Slightly more complex.
Requires volatile (Java 5+) to prevent partial object initialization issues.
Reflection vulnerability unless guarded.
When to Use
Multi-threaded apps with frequent getInstance() calls.
When balancing performance and thread safety.

5. Initialization-on-Demand Holder Idiom
This leverages Java’s class loading to achieve lazy loading and thread safety without synchronization.
Pros
Thread-safe (JVM guarantees class initialization is thread-safe).
Lazy-loaded—Holder class is loaded only when getInstance() is called.
No synchronization overhead.
Simple and elegant.
Cons
Reflection can still bypass unless guarded.
No way to pass parameters during initialization.
When to Use
Preferred for most cases due to simplicity and performance.
Multi-threaded apps needing lazy loading.



6. Enum Singleton
Using an enum is a modern, robust way to implement a Singleton, introduced in Java 5.
Pros
Thread-safe by design (JVM handles enum initialization).
Immune to reflection attacks (enums can’t be instantiated via reflection).
Serialization-safe (enums handle serialization automatically).
Extremely concise.
Cons
No lazy loading—enums are initialized when the enum class is loaded.
Limited flexibility (can’t extend other classes or pass parameters easily).
May feel unconventional for some use cases.
When to Use
When simplicity and robustness are priorities.
When serialization or reflection safety is critical.
Important Note on Thread Safety:
The simple example above is not thread-safe. In a multithreaded environment, it's possible for multiple threads to enter the if (instance == null) block simultaneously and create multiple instances of the Singleton. For thread-safe Singleton implementations, you would need to use techniques like synchronization or the inner static helper class approach (as shown in the previous example). However, this simple example effectively illustrates the core concept of the Singleton pattern.

MORE……………..


26. IMMUTABLE CLASS----------------------------------------------
An immutable class in java is a class whose objects, once created, cannot be modified and remains constant throughout its lifetime. Any attempt to change an immutable object results in the creation of a new object with the updated state and leaving the original unchanged.
Examples of immutable classes is 
1.	String
2.	Integer, Double and other wrapper classes
3.	LocalData, localTime
Characteristics of immutable  classes
•	No modification after creation
•	Thread safe by default
•	Safe to share
•	Good for caching and hashing
Why to  use immutable classes?
Thread Safety: No state changes = safe sharing across threads (no synchronization needed).
Predictability: No state changes = easy reasoning, no unexpected side effects.
Collection Safety: Consistent behavior as HashMap keys/HashSet elements (stable hash codes).
Cacheability: Safe caching and reuse (e.g., String pool).
Failure Atomicity: Operations leave them in a consistent state.
Simplified Design: No defensive copies or complex state management required.
HOW TO CREATE AN IMMUTABLE CLASS?
•	Make the class final → Prevents subclassing.
•	Make all fields private and final → No direct access/modification.
•	No setter methods → Only provide getters.
•	Perform deep copy in constructors/getters → Avoid external modification.
•	Do not return mutable objects directly → Defensive copying.
•	Return new instances for changes method that appears to modify object should return new instance.


27. FINAL KEYWORD----------------------------------------------------------------
Final keyword in java is a modifier that restricts modification or extension, depending on what its applied to. Final keyword enforces immutability 
Why do we need it?
It prevent modification on members which you don’t want to change in future.
It improves code understanding and readability.
Finals fields ensure safe publication in multi-threaded environments.
>final variable
A final variable is a variable whose value(for primitive) or reference (for objects) cannot be changed once initialized. Its essentially a constant or a fixed reference.
It must be initialized at declaration or in constructor.
For primitives the value cannot change. AND for objects the reference cannot change, but the object internal state can (unless the object itself in immutable).
>final fields conventionally names in UPPER_SNAKE_CASE.
Types of final variables.
1.	Final instance variable
2.	Final static variable(global constant)
3.	Final local  variable
4.	Final parameter(in method)

>final methods
A final method in a class cannot be overridden by subclass. It locks the method implementation, ensuring its behavior remains consistent in derived classes.
The subclasses can call the final method but cannot redefine it. Static methods are implicitly final since they are not overridden
Benefits:
Ensure critical methods are not altered.
Prevent subclasses from bypassing security checks.
Enables jvm optimizations

>final class
A final class cannot be extended which  means no subclasses can be created. It is used to prevent inheritance, locking the class behavior and structure.


28. ENCAPSULATION------------------------------------------------------
Encapsulation in the oops principle of wrapping data and methods that operate on that data within a single unit i.e. class, while restricting direct access to some the object components.
Encapsulation encapsulate the fields into one single unit and resist direct access of that fields and promotes data hiding. Declaring fields as private to hide them from external access. Providing controlled access to these fields through public methods, typically getters and setters.
It is like an ATM that hides internal working but provides controlled access via buttons.
Why do we need it in code?
Data hiding, control over data, flexibility, reusability, security, prevent unwanted modifications.
Key Components 
•	Private field: store the object state and are hidden from the external classes.
•	Public methods: provide controlled access using setter and getter
•	Class as a unit: combines data and behavior, ensuring they are tightly coupled.
Rules to follow to achieve encapsulation;
1.	Declare class variable as private = prevent direct access
2.	Provide public getter and setter methods = controlled access
3.	Add validation in setters(if needed) = ensure data integrity
Use of getter(accessor) and setter(mutator) methods
Getters and setters are public methods in a java class that provides controlled access to private fields:
The getter method that retrieves the value of private field
The setter method that modifies the value of private field
Why to use it?
It hides the internal representation of the class state, preventing direct access to the fields. It allow validation, logging or other logic when getting or setting values. It maintain flexibility and ensure data integrity. Supports immutability by providing getter without setters for read only fields.
Naming conventions:
Getter=> for any variable name age the getter is getAge()
Setter=>for any variable name age the setter is setAge(..)
Implementation::
1.	Declare fields as private to restrict direct access.
2.	Providing a public getter to read the fields value.
3.	Providing a public setter(if modification is allowed) to update the fields value, often with validation.
Types of getter and setter:::::
1. standard getters and setters (mostly used).
2. Boolean getters (for Boolean fields, getters often use isFieldName() instead of getFieldName() ).
3. derived getters (return computed values instead of direct field values).
4. no setter (for read only, provides only getter used for sensitive and immutable fields).
5. custom setters (use descriptive names instead of setFieldName for specific actions).






29. INHERITANCE---------------------------------------------------------------------------------------
Inheritance in java is a mechanism where any new class inherits properties and behavior from an existing class.
Superclass (parent class) == the class being inherited from
Subclass (child class) == the class that inherits.
Extends == keyword used to inherit
IS-A relationship == it established an is-a relationship, where the subclass is a specialized version of the superclass.
Why to use inheritance?
1.	It reduce code duplication by defining common code in superclass once and reused by subclasses.
2.	Enhance modularity by organizing code into hierarchical structures, improving readability and maintenance.
3.	Support polymorphism and facilitates extensibility.



Syntax:
class Superclass {
    // Fields, constructors, methods
}
class Subclass extends Superclass {
    // inherits all non-private members
    // Additional fields, constructors, methods
    // Can override inherited methods
}
Super keyword
The super keyword is a reference to the immediate superclass of the current class. The super keyword used by the child class work as the way to get something from the parent class.
Main use fo the super keyword:
I.	Calling a Superclass Constructor (super()).
II.	Accessing Superclass Methods (super.methodName()).
III.	Accessing Superclass Fields (super.fieldName).
1.calling a superclass constructor::
When creating a subclass object, the superclass must be initialized first. Java will automatically insert a call to the no-argument constructor(default constructor) of the parent class as the very first statement in the child class constructor. You can invoke the constructor of the  super class explicitly using super() or super(args) keyword.
Super() calls the no args constructor of the superclass.
Super(args) call the parameterized constructor of the superclass.
>these super keywords must be the first statement in the subclass constructor.
>if the superclass does not have a no-args constructor, then it throw a compilation error unless you explicitly call a parameterized constructor with super(args).

<>you can call only one constructor of the parent class using one super() keyword because super must be the first statement in the constructor of the child class but you can make multiple constructor in child class and call different constructor from the parent class<>

>>any method inside the child class can call the parent method directly if the name of methods are different. But if they have same method name then child class must use super.methodname();. Also super.fieldname() can access a superclass field, especially when the subclass has a field with the same name called as field hiding.

>>super keyword is also used in inner class but some rules present here like in an inner class super refers to the superclass of the inner class , not the enclosing class. To access the enclosing class you would use enclosingClass.this .
What super keyword can do:
•	Can call the superclass constructor 
•	Can access superclass members
•	Work in multi level inheritance hierarchies
•	Support polymorphism by allowing subclass to extend or customize superclass behavior while reusing it.
 What super keyword cannot do:
•	Cannot call grandparent class directly
•	It cannot be used in static methods or blocks
•	It cannot access private fields or methods of the superclass
•	Cannot be used with this() in the same constructor
•	Cannot call constructor outside constructors


summary
I.	Constructor calls (super() or super(args)) for initialization.
II.	Method calls (super.methodName()) to reuse or extend behavior.
III.	Field access (super.fieldName) to resolve naming conflicts.
No super in Object Class: Since java.lang.Object is the root of all classes and has no superclass, super is meaningless in Object.

Method overriding 
If subclass has a method m with the same signature as of the method present in the superclass, then method m overrides the method of the superclass.
For instance method (overriding): must have the same method name, same number and type and order, same return type, same access modifier. It can be invoke through an object reference and consider as runtime polymorphism. 
If the child class have override the parent class method then to call the parent class method you have to use super.methodname(); 
>super can only be used within  an instance method of a subclass. You cannot use super in a static method or directly within the class declaration.
For static method (shadowing, hiding not overriding): 
You cannot override a static method in the way you override instance methods. Static methods are associated with the class itself, not with any specific instance of the class, so you typically call them using class name like myclass.myStaticMethod();. And there is no runtime polymorphism involved for static methods, so when you call a static method, the compiler determines which method to execute based on the reference type you are using.
>Final method cannot be overridden in any case in java.
NOTE:: the instance variable is not accessible by the static method as static method operates in class level context but instance method can directly access static members.

Access modifiers and inheritance
public: Inherited and accessible everywhere.
protected: Inherited and accessible in the same package and subclasses (even in different packages).
Default (package-private): Inherited and accessible only in the same package.
private: Not inherited; inaccessible to subclasses directly (use getters/setters).

Covariant return type<><><><>study it

Constructor in inheritance
A subclass constructor must call a superclass constructor in order to initialize it explicitly via super() or implicitly if the superclass has a no-arg constructor.
Technically constructor are not inherited, but subclasses can call them using super() keyword.
And if superclass have no arg constructor and sub class have not call that using super() then java provides a no-arg constructor. Which the subclass can call implicitly.
<><> every class in java implicitly inherits from java.lang.Object, the root of the class hierarchy. Methods like toString(), equals() and hashcode() are inherited and can be overridden.  <><>
<><>  final class cannot be extended and final method  cannot be overridden by subclasses.  <><>
Polymorphism and inheritance-------
Inheritance enables polymorphism, where a subclass object can be treated as a subclass type which allow:
Upcasting: assigning a subclass object to a superclass reference.
Dynamic method dispatch: the JVM calls the overridden method of the actual object type at runtime.
Types of inheritance in java
Java supports 3 types of inheritance as multiple inheritance is not directly supported for classes to avoid complexity.
1.SINGLE INHERITANCE
One subclass extends one superclass.

2. MULTILEVEL INHERITANCE
A class extends a subclass forming a chain like (A->B->C).
3. HIERARCHICAL INHERITANCE
Multiple classes extend the same superclass.
4. MULTIPLE INHERITANCE
Java does not allow a class to extend multiple classes to avoid the diamond problem(ambiguity when two superclasses defines the same method). Multiple inheritance means there are two class and third class is trying to inherit from both the superclass.
But this can be achieve using interfaces like
(class C implements A, B)
DIAMOND PROBLEM=
This occurs in multiple inheritance when a class inherits confliction methods from two superclasses.
This can be avoid by allowing only single inheritance for classes. And resolving interface method conflicts explicitly (since java 8 with default methods)

>In short a subclass 
can inherits all public and protected members of the superclass and default (package-private) members (if in the same package).
Cannot inherits private members directly and constructor but can be called via super().
>overriding is redefining a superclass method with the same signature  in the subclass.
>covariant return type introduce in java 5 that allow a subclass method to override a superclass method with a more specific return type i.e. subtype of the original return type.
>abstract classes are designed for inheritance, providing a partial implementation that subclasses complete.
>classes can implement multiple interfaces, inheriting their abstract methods.






30. POLYMORPHISM--------------------------------------------------------------------
Poly means many and morph means forms which combined and state the ability of an object to behave differently in different situations.
It allows object of different classes to be treated as objects of a common type, enabling a single interface to represent different underlying  implementations.
In java polymorphism is primarily achieved through inheritance, interfaces, method overriding, method overloading
Why is it important?
•	Allow code to work with different types through a common interface or superclass.
•	New subclasses or  implementations can be added without modifying existing code.
•	Hides implementation details focusing on what objects do rather than how they do it.
There are two main types of polymorphism which is static and dynamic polymorphism.
1. compile time / static polymorphism 
This is achieved through method overloading. The compile time polymorphism occurs when the method to be called is determined by the compiler at compile time based on the method signature(name and parameter types).
Method overloading allows a class to have multiple methods with the same name but different parameter list like different number, types or order of parameters. The compiler decides which method to call based on the arguments provided.
Rules of method overloading:
•	Method must have the same name
•	Method must differ in 
1.1.	Number of parameters
1.2.	Types of parameters
1.3.	Order of parameter types
•	Return type alone is not sufficient to differentiate overloaded methods.
•	Access modifiers or exceptions thrown do not affect overloading.
Operator overloading
Limited in java as java does not support user-defined operator overloading like c++. However, some operator for example + exhibit polymorphic behavior.
For numbers 2+3=5
For strings “hello”+”kitty”=hellokitty
This is a form of compile-time polymorphism, as the behavior of + is determined by the operand types at compile time.
2. runtime / dynamic polymorphism
Runtime polymorphism is the ability of a program to decide which method to call at runtime, based on the actual object type, not the variable’s declared type.
This is achieved through method overriding, 
inheritance or interface = a superclass or interface provides a common type, and subclasses or implementing classes provide the actual behavior.
dynamic method dispatch= the jvm resolves the method call at runtime by looking at the object actual type.
Rules of method overriding:
•	The method  must have the same signature(name, parameters, return type) as in the superclass.
•	The access modifier must be same or less restrictive.
•	The method must not throw new or broader checked exceptions.
•	Use the  @override annotation to ensure correct overriding.
•	The return type can be a covariant subtype(since java 5).
•	Method marked final or static cannot be overridden (static method can be hidden, not overridden).
Polymorphism with data members
>variables are not polymorphic in java only methods are.
>variable access is determined by the reference type, not the object type.
Polymorphism in read world applications like java collection framework, jdbc api, gui event handling.

upcasting
upcasting is when a subclass object is assigned to a superclass or interface reference. Its safe and implicit because a subclass is a superclass or interface type.
Why use it?
•	Enables polymorphism by allowing the reference type to be more general.
•	Facilitates collections of mixed types
downcasting
downcasting is when a superclass or interface reference is cast to a subclass type. Its explicit and potentially unsafe, requiring a type check eg using instanceof
Dynamic method dispatch
Dynamic method dispatch is the process by which the JVM determines at runtime which overridden method to call on the actual object type, not the reference type. And its working includes the object virtual table (vtable) used by JVM to resolve the method call at runtime. Only overridden methods are dispatched dynamically.
Covariant return type
Since java 5 overridden methods can return a subtype of the superclass return type.
>final methods: cannot be overridden, preventing polymorphic behavior for that method.
>final classes: cannot be extended, limiting inheritance-based polymorphism.










31. ENCAPSULATION
Discussed above about setter and getter and more which not will be discuss later








32. ABSTRACTION-------------------------------------------------------------------
One of the four pillars of oops in java, alongside encapsulation, inheritance and polymorphism. It is the process of hiding complex implementation details and exposing only the essential features or behavior of an object to the user.
Abstraction allow developers to focus on what an object does rather than how it does it.
In java abstraction is primarily achieved through:
1.	Abstract class: partially implemented classes that define a blueprint for subclasses.
2.	Interfaces: fully abstract contracts that specify behavior without implementation.
Key characteristics:
•	Hide implementation like internal logics.
•	Exposed interface like only necessary methods or behavior are visible to the user.
•	Promotes generalization by defining common behavior for related classes.
Why to use it?
Reduces complexity by simplifying interaction by hiding unnecessary details, making systems easier to understand.
Improves maintainability, enhances modularity, promotes reusability, improve designs etc

Level of abstraction
1.	Full abstraction (interfaces pre-java 8)
2.	Partial abstraction (abstract classes)
3.	Zero abstraction (concrete classes)

1. abstract classes
An abstract class is a class that cannot be instantiated directly and serves as a blueprint for subclasses. It is defined with abstract keyword(non-access modifier). And it can contain abstract methods, concrete methods, fields(instance and static variables) and constructors.
Abstract classes are ideal when you want to provide a partial implementation and share common code among related classes.
The abstract class must be extended by a subclass
Subclass must implement all abstract methods(unless its also abstract)
Abstract class is a restricted class that cannot be used to create objects in order to access it, it must be inherited from another class. As no object of abstract class can be.
Abstract method can only be used in an abstract class and it does ot have a body. The body is provided by the subclass.

Upcasting can be done with abstract class and methods. Which means assigning a reference of a subclass type to a reference of its superclass type. 

